-- Automation rules for rule-based CRM automations.
-- Trigger types: deal_stage_change, contact_created
-- Action types: create_task, add_note (future: send_email)
-- Rules are scoped per sales_id (per user).

create table "public"."automation_rules" (
    "id" bigint generated by default as identity primary key,
    "sales_id" bigint not null references sales(id) on delete cascade,
    "name" text not null,
    "enabled" boolean not null default true,
    "trigger_type" text not null,
    "trigger_config" jsonb not null default '{}'::jsonb,
    "action_type" text not null,
    "action_config" jsonb not null default '{}'::jsonb,
    "created_at" timestamptz not null default now(),
    "updated_at" timestamptz not null default now()
);

alter table "public"."automation_rules" enable row level security;

create index automation_rules_sales_id_idx on public.automation_rules (sales_id);

-- Trigger: set sales_id on insert (like other tables)
create trigger set_automation_rules_sales_id_trigger
before insert on public.automation_rules
for each row
execute function set_sales_id_default();

-- RLS: users can only access their own rules
create policy "Users can manage own automation rules"
on public.automation_rules
for all
to authenticated
using (
    sales_id in (select id from sales where user_id = auth.uid())
)
with check (
    sales_id in (select id from sales where user_id = auth.uid())
);

grant select, insert, update, delete on public.automation_rules to authenticated;
grant all on public.automation_rules to service_role;

-- Auto-update updated_at on automation_rules
create or replace function public.set_automation_rules_updated_at()
returns trigger language plpgsql as $$
begin
  new.updated_at = now();
  return new;
end;
$$;
create trigger automation_rules_updated_at_trigger
before update on public.automation_rules
for each row execute function public.set_automation_rules_updated_at();

-- Function: evaluate automation rules on deal stage change
-- trigger_config for deal_stage_change: { "target_stage": "won" } or { "from_stage": "proposal", "target_stage": "won" }
create or replace function public.evaluate_automation_rules_on_deal()
returns trigger
language plpgsql
security definer
set search_path = ''
as $$
declare
    rule_record record;
    action_cfg jsonb;
    task_text text;
    task_type text;
    due_offset_days int;
    contact_id_val bigint;
begin
    for rule_record in
        select ar.id, ar.sales_id, ar.action_type, ar.action_config
        from public.automation_rules ar
        where ar.enabled = true
          and ar.trigger_type = 'deal_stage_change'
          and ar.sales_id = new.sales_id
          and (ar.trigger_config->>'target_stage') = new.stage
          and (
              (ar.trigger_config->>'from_stage') is null
              or (ar.trigger_config->>'from_stage') = old.stage
          )
    loop
        if rule_record.action_type = 'create_task' then
            action_cfg := rule_record.action_config;
            task_text := coalesce(action_cfg->>'text', 'Follow up');
            task_type := coalesce(action_cfg->>'type', 'call');
            due_offset_days := coalesce((action_cfg->>'due_offset_days')::int, 7);

            -- Get first contact from deal if contact_ids exists
            if new.contact_ids is not null and array_length(new.contact_ids, 1) > 0 then
                contact_id_val := new.contact_ids[1];
            else
                contact_id_val := null;
            end if;

            -- If we have a contact, create task
            if contact_id_val is not null then
                insert into public.tasks (contact_id, sales_id, type, text, due_date)
                values (
                    contact_id_val,
                    rule_record.sales_id,
                    task_type,
                    task_text,
                    now() + (due_offset_days || ' days')::interval
                );
            end if;
        end if;
    end loop;

    return new;
end;
$$;

create trigger automation_rules_deal_stage_trigger
after update of stage on public.deals
for each row
when (old.stage is distinct from new.stage)
execute function public.evaluate_automation_rules_on_deal();

-- Function: evaluate automation rules on contact created
create or replace function public.evaluate_automation_rules_on_contact()
returns trigger
language plpgsql
security definer
set search_path = ''
as $$
declare
    rule_record record;
    action_cfg jsonb;
    task_text text;
    task_type text;
    due_offset_days int;
begin
    for rule_record in
        select ar.id, ar.sales_id, ar.action_type, ar.action_config
        from public.automation_rules ar
        where ar.enabled = true
          and ar.trigger_type = 'contact_created'
          and ar.sales_id = new.sales_id
    loop
        if rule_record.action_type = 'create_task' then
            action_cfg := rule_record.action_config;
            task_text := coalesce(action_cfg->>'text', 'Welcome new contact');
            task_type := coalesce(action_cfg->>'type', 'call');
            due_offset_days := coalesce((action_cfg->>'due_offset_days')::int, 7);

            insert into public.tasks (contact_id, sales_id, type, text, due_date)
            values (
                new.id,
                rule_record.sales_id,
                task_type,
                task_text,
                now() + (due_offset_days || ' days')::interval
            );
        end if;
    end loop;

    return new;
end;
$$;

create trigger automation_rules_contact_created_trigger
after insert on public.contacts
for each row
execute function public.evaluate_automation_rules_on_contact();
