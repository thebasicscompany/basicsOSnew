-- Enable pgvector extension
create extension if not exists vector;

-- Add Basics API key to sales (per-user). Store encrypted; for MVP we store plaintext.
-- TODO: Use Supabase Vault or app-level encryption for production.
alter table "public"."sales"
  add column if not exists "basics_api_key" text;

-- Context embeddings table for RAG
create table if not exists "public"."context_embeddings" (
  "id" bigint generated by default as identity primary key,
  "sales_id" bigint not null references "public"."sales"(id) on delete cascade,
  "entity_type" text not null,
  "entity_id" bigint not null,
  "chunk_text" text not null,
  "embedding" vector(1536),
  "created_at" timestamptz not null default now(),
  "updated_at" timestamptz not null default now(),
  unique ("sales_id", "entity_type", "entity_id")
);

alter table "public"."context_embeddings" enable row level security;

-- RLS: users can only access their own embeddings (via sales_id)
create policy "Users can manage own context embeddings"
  on "public"."context_embeddings"
  for all
  to authenticated
  using (
    sales_id in (select id from "public"."sales" where user_id = auth.uid())
  )
  with check (
    sales_id in (select id from "public"."sales" where user_id = auth.uid())
  );

-- Grant service_role full access (for API)
grant all on "public"."context_embeddings" to service_role;

-- Vector similarity search: cosine distance (<=>)
create index if not exists context_embeddings_embedding_idx
  on "public"."context_embeddings"
  using ivfflat (embedding vector_cosine_ops)
  with (lists = 100);

create index if not exists context_embeddings_sales_id_idx
  on "public"."context_embeddings" (sales_id);

-- RPC for similarity search (used by API adapter)
create or replace function "public"."match_context_embeddings"(
  p_sales_id bigint,
  p_query_embedding vector(1536),
  p_match_count int default 5
)
returns table (
  entity_type text,
  entity_id bigint,
  chunk_text text
)
language sql
stable
security definer
set search_path = public
as $$
  select
    ce.entity_type,
    ce.entity_id,
    ce.chunk_text
  from context_embeddings ce
  where ce.sales_id = p_sales_id
    and ce.embedding is not null
  order by ce.embedding <=> p_query_embedding
  limit p_match_count;
$$;

grant execute on function "public"."match_context_embeddings"(bigint, vector(1536), int) to authenticated;
grant execute on function "public"."match_context_embeddings"(bigint, vector(1536), int) to service_role;
