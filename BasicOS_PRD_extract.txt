BasicOSProduct Requirements DocumentHow to Build It, Host It, Sell It, and Ship ItBasics · February 17, 2026Version 4.0 — Consolidated1. What BasicOS IsBasicOS is an open-source monorepo that a company clones to get a complete internal operating system. Not a collection of templates — a full product suite: a Notion-class knowledge system, an enterprise-grade CRM, an AI-powered meeting intelligence system, a company-wide automation engine, autonomous AI employees running in sandboxed VMs, and an always-present desktop overlay that coaches employees through any task, answers questions grounded in company data, and records workflows that train AI agents.It ships five platform targets from one codebase: a macOS desktop app (Electron) with a transparent AI overlay, an iOS mobile app (React Native/Expo), a web portal (Next.js), and two MCP servers (one for engineering teams, one for the whole company). All five share a single backend, a single database schema, and a single authentication system. The Company Assistant — an AI grounded in all company data — is accessible from every surface.Companies clone the repo, customize it with their branding, and deploy it. The repo is structured with CLAUDE.md context files and Claude Code skills throughout, so any AI coding tool can understand the entire system and build new tools on top of it. The module system lets a developer (or Claude Code) scaffold a complete new business tool that works across all five platforms in under an hour.HOW WE MAKE MONEYThe software is free and open source. Revenue comes from two things: (1) one managed API key that covers AI, text-to-speech, and speech-to-text so companies do not have to set up provider accounts themselves, and (2) managed hosting so companies do not have to manage infrastructure. We build and operate a platform at basics.so where customers sign up, get their API key, and optionally get one-click hosting.2. Architectural DecisionsThese are final. No feasibility discussion — just the rulings.DecisionChoiceWhyMonorepo toolTurborepo + pnpm 9Proven at Cal.com and Supabase. 3x faster than Nx at our scale.Desktop frameworkElectron v33+Only framework with mature overlay, click-through, desktopCapturer, and tray APIs.Mobile frameworkExpo SDK 54+Official React Native recommendation. Eliminates Xcode configuration.Web frameworkNext.js 15+ (App Router)68% market share. Best tRPC integration. Server Components for admin panels.Backend / APItRPC v11 + Hono v4End-to-end type safety from DB to UI. Hono is 3x faster than Express.ORMDrizzle v0.44+Code-first TypeScript schema. 7.4KB bundle. Native SQLite and Postgres support.DatabasePostgreSQL (Neon) + Turso (local SQLite)Neon for cloud. Turso embedded replicas for offline-first desktop/mobile.AuthBetter Auth v1Open-source. Multi-platform. Stores data in our own DB via Drizzle adapter.Real-time syncYjs v13 (CRDTs)Used by Notion and ClickUp. 900K+ weekly downloads.API proxyLiteLLM100+ LLM providers. Built-in virtual keys, budgets, rate limiting.AI sandboxE2B (Phase 3)Firecracker microVMs. 150ms cold start. Do not build this ourselves.BillingStripe Billing MetersUsage-based invoicing without running a separate billing engine.Shared UITailwind v4 + Radix (web/desktop), Tamagui (mobile)Maximum platform fidelity on each target.MCP SDK@modelcontextprotocol/sdkOfficial TypeScript SDK. Works with Claude, ChatGPT, Copilot, Cursor.LicenseAGPL-3.0 + CLAProtects against cloud providers reselling. Allows commercial self-hosting.3. Who Uses BasicOS and HowThere are four distinct user types. Each interacts with different parts of the system.3.1. The Founding CTO / Technical FounderWhat they do: Discover BasicOS, clone the repo, set it up, customize branding, choose which template modules to activate, and deploy for their team. Decides between self-hosting (free) and managed hosting (paid).Their journey: GitHub → Clone repo → Run setup wizard → Configure branding, domain, modules → Deploy (Docker Compose or basics.so one-click) → Invite team → Manage the OS going forward.What they care about: Ownership, extensibility, not paying for 15 SaaS tools, being able to use Claude Code to build new internal tools on top of the OS.3.2. The EngineerWhat they do: Use the desktop app daily. Connect their AI coding tools (Claude Code, Cursor, Copilot) to the Engineer MCP server. When someone on the team updates a CLAUDE.md, skill, or agent config, it automatically syncs to their environment.Their journey: Get invited → Download desktop app from portal → Log in → Connect Claude Code to Engineer MCP server → Start coding with full team context → Propose config changes that propagate to everyone.What they care about: Their AI tools knowing everything about the codebase without manually pasting context. Environment consistency across the team.3.3. The Non-Technical Employee (Sales, Ops, Marketing)What they do: Use the web portal and mobile app. Chat with the company AI chatbot to get answers grounded in company data. Use the CRM, task manager, and other template tools. Never touch code.Their journey: Get invite email → Create account on web portal → Complete onboarding flow → Use company chatbot, CRM, task manager daily → Connect ChatGPT or Claude to Company MCP server for AI-powered queries.What they care about: Getting answers fast. Not needing to ask an engineer to pull data.3.4. The IT Admin / CTO (Ongoing)What they do: Manage the system after deployment. Monitor AI spend, set budgets, rotate API keys, configure PII redaction, manage roles, review audit logs.Their journey: Log into web portal admin dashboard → Monitor usage and spend → Set budgets → Review security events → Rotate API keys → Manage team roles.What they care about: Cost control, security, compliance, not getting a surprise $10K bill.4. The Basics Platform: What We Build and OperateBasicOS is the open-source repo that companies clone. But we (Basics, the company) also build and operate a platform alongside it. This platform is how we make money and deliver value to paying customers. Here is everything we build and run.4.1. The Website: basics.soOur public-facing website serves three purposes:Marketing site: explains what BasicOS is, screenshots, links to GitHub, pricing page.Customer dashboard: where paying customers sign up, manage subscriptions, view API keys, see usage analytics, and access one-click deploy.Documentation site: full docs for self-hosting, module development, MCP server setup, API reference.Tech stack: Next.js (same framework as the OS web portal, so we dogfood our own stack). Hosted on Vercel for marketing/docs. Customer dashboard is a separate Next.js app sharing packages/api and packages/db from the BasicOS monorepo.4.2. The API Proxy: api.basics.soThis is the core of our monetization. A LiteLLM instance we deploy on Railway and operate as a managed service.How we set it upCreate master accounts with every AI provider: OpenAI, Anthropic, Google, AWS Bedrock, Deepgram (STT), ElevenLabs (TTS).Deploy LiteLLM Proxy as a Docker container on Railway, configured with our master API keys. Exposes an OpenAI-compatible endpoint at api.basics.so.Configure PostgreSQL (same Neon instance as customer dashboard) for virtual keys, usage logs, and spend tracking.Configure Redis (Upstash) for real-time rate limiting and key validation caching.LiteLLM handles LLM, embedding, and image generation natively. For TTS (ElevenLabs) and STT (Deepgram), we add a lightweight Hono middleware that validates against the same virtual key database and logs usage.How a customer gets their keyCustomer signs up at basics.so and picks a plan (Starter $29/mo, Team $99/mo, Enterprise custom).Stripe Checkout collects payment. Webhook fires to our backend.Backend calls LiteLLM Admin API: POST /key/generate with tenant_id, allowed models, budget limit, rate limits.Virtual key (bos_live_sk_...) generated, hashed, stored. Displayed to the customer exactly once.Customer copies it into their BasicOS .env file: BASICOS_API_KEY=bos_live_sk_...Every AI, TTS, and STT request from their entire company now routes through our proxy. No OpenAI, Anthropic, or Deepgram accounts needed.How billing worksEvery request through the proxy, LiteLLM logs: tenant_id, model, tokens (or audio seconds, or characters), and cost in USD.Background worker runs hourly, aggregates usage per customer, sends Stripe Meter Events.Stripe auto-generates invoices: base subscription + overage charges beyond included credits.We mark up provider costs by 20–30%. Example: OpenAI charges us $0.01/1K tokens, we charge ~$0.013/1K.Usage Alerts fire at 80% budget. Admin gets an email. If exhausted, requests return 429 with upgrade prompt.4.3. The Hosting Platform: deploy.basics.soFor customers who do not want to manage infrastructure, we offer managed hosting.How we set it upWe use Railway as our hosting provider. Railway supports multi-service projects with git-push deploys, auto builds, usage-based pricing.We create a Railway Template: a pre-configured project with the BasicOS web portal, API server, Company MCP server, PostgreSQL, Redis, and LiteLLM proxy.When a customer clicks "Deploy" on basics.so, our backend uses the Railway API to clone the template into a new project for that customer.DNS: customer enters their domain (os.acmecorp.com). We provision SSL via Let’s Encrypt and configure the reverse proxy.Within 3–5 minutes, the customer has a running BasicOS at their custom domain.How updates work for managed customersWe push an update to the BasicOS repo. CI/CD (GitHub Actions + Turborepo) builds only affected packages.For managed customers, we trigger a Railway redeploy via API. Zero-downtime rolling updates.Customer’s web portal, MCP servers, and API proxy update automatically.Desktop app checks for updates on launch via Electron autoUpdater.Customer gets a changelog notification in the web portal and via email.Multi-tenancyShared-schema multi-tenancy with PostgreSQL Row-Level Security. Every table has tenant_id. Middleware extracts from JWT. RLS policies filter all queries. One database serves all managed customers with zero cross-tenant leakage. Enterprise customers can get dedicated single-tenant deployments at a premium.4.4. What We Operate Day-to-DayServiceWhereWhat It Doesbasics.so (marketing)VercelMarketing pages, docs, blogbasics.so (dashboard)RailwayCustomer signup, API key management, billing, usage analyticsapi.basics.soRailwayLiteLLM proxy + TTS/STT middleware. All customer AI traffic.deploy.basics.soRailway APIProvisions and manages hosted customer instancesPostgreSQLNeonCustomer data, virtual keys, usage logs, spend trackingRedisUpstashRate limiting, key validation cache, real-time usage counters5. The Unified Backend ArchitectureEvery platform — the web portal, the desktop app, the mobile app, and both MCP servers — connects to one backend. There is no separate API for the CRM, a separate API for the Knowledge System, a separate API for meetings. One tRPC API server handles everything. One PostgreSQL database stores everything. One event system connects everything. This section explains how that backend is designed, how data flows through it, and how all the core products stay in sync.WHY THIS MATTERSA company OS that feels fragmented — where the CRM does not know about meetings, where the chatbot cannot see tasks, where automations cannot trigger across products — is just a bundle of separate tools. The entire value of BasicOS is that everything is connected. The backend architecture is what makes that connection possible.11.1. The API ServerA single Hono v4 HTTP server that hosts the tRPC router. Every client — web, desktop, mobile, MCP — talks to this one server. There is no API gateway, no microservices, no separate backends per product. One process, one router, one set of middleware.Request lifecycleClient sends a tRPC request (HTTP POST to /trpc/[procedure]). Can be a query (read) or mutation (write).Hono middleware chain runs: CORS → rate limiting (Redis) → auth verification (Better Auth, extracts user ID + tenant ID from JWT) → tenant context injection (sets PostgreSQL session variable for RLS).tRPC procedure executes. Input validated by Zod schema. Business logic runs. Drizzle queries the database (all queries auto-filtered by RLS — the procedure never manually filters by tenant_id).If the mutation triggers a side effect (e.g., CRM deal stage changed), the procedure emits an event to the Event Bus (Section 5.5).Response returned to client. If it’s a subscription (real-time), the connection stays open via Server-Sent Events.The tRPC router treeEvery core product registers its router as a sub-router of the main app router. This is what gives us end-to-end type safety from database to UI:// packages/api/index.tsexport const appRouter = router({ // Core products assistant: assistantRouter, // Company Assistant (chat, search, RAG) knowledge: knowledgeRouter, // Knowledge System (docs, pages, search) crm: crmRouter, // CRM (contacts, companies, deals, pipeline) meetings: meetingsRouter, // Meeting Intelligence (transcripts, summaries) tasks: tasksRouter, // Task Manager (todos, boards, assignments) automations: automationsRouter, // Automations Engine (workflows, triggers) aiEmployees: aiEmployeesRouter, // AI Employees (jobs, status, approvals) hub: hubRouter, // The Hub (integrations, links, services) // Platform auth: authRouter, // Authentication, sessions, invites admin: adminRouter, // Admin panel (team, billing, branding) notifications: notificationsRouter,// Push + in-app notifications files: filesRouter, // File uploads (S3-compatible, Cloudflare R2) search: searchRouter, // Unified search across all products // Module system (Section 10) modules: modulesRouter, // Dynamic module registry})Every router in this tree is defined in packages/api/routers/[name].ts. Every router imports its Zod validators from packages/shared/validators/[name].ts. Every router uses protectedProcedure (requires auth) or adminProcedure (requires admin role). No exceptions.How each platform connectsPlatformTransportClient LibraryHow It Calls the APIWeb portal (Next.js)HTTP@trpc/react-queryDirect tRPC client. Server Components use server-side caller. Client Components use React Query hooks.Desktop app (Electron)HTTP@trpc/react-querySame tRPC client as web. Renderer process calls the API server URL (local or remote).Mobile app (Expo)HTTP@trpc/react-querySame tRPC client. React Native compatible via fetch adapter.Company MCP serverDirect importDirect router callerMCP server imports appRouter and calls procedures directly (no HTTP). Same process or same-machine IPC.Engineer MCP serverHTTPtRPC vanilla clientCalls the API server over HTTP for config sync and team context.Key insight: The Company MCP server does not duplicate business logic. When an employee asks ChatGPT "What’s the ACME deal status?" and ChatGPT calls the MCP server’s query_crm tool, that tool calls crm.getById on the same tRPC router that the web portal uses. One implementation, multiple interfaces.11.2. The Database LayerOne PostgreSQL database (Neon for cloud, or self-hosted Postgres). One Drizzle schema. All core products share the same database with proper foreign key relationships between them. This is what enables the Company Assistant to search across everything in one query — it is all in the same database.Schema overview// Core tables (simplified, all have tenant_id + RLS) // Auth & Orgtenants { id, name, logo_url, accent_color, domain, plan }users { id, tenant_id, email, name, role, avatar_url }sessions { id, user_id, token, expires_at }invites { id, tenant_id, email, role, accepted_at } // Knowledge Systemdocuments { id, tenant_id, parent_id, title, content_json, created_by, updated_at }document_embeddings { id, document_id, chunk_text, embedding vector(1536), chunk_index } // CRMcontacts { id, tenant_id, name, email, phone, company_id, custom_fields jsonb }companies { id, tenant_id, name, domain, industry, custom_fields jsonb }deals { id, tenant_id, company_id, contact_id, title, stage, value, probability, close_date }deal_activities { id, deal_id, type, content, created_by, created_at } // Meeting Intelligencemeetings { id, tenant_id, title, started_at, ended_at, calendar_event_id }meeting_participants { meeting_id, user_id, external_email }transcripts { id, meeting_id, speaker, text, timestamp_ms }meeting_summaries { id, meeting_id, summary_json, action_items jsonb }meeting_embeddings { id, meeting_id, chunk_text, embedding vector(1536) } // Task Managertasks { id, tenant_id, title, description, status, priority, assignee_id, due_date, source_type, source_id } // Automations Engineautomations { id, tenant_id, name, trigger_config jsonb, action_chain jsonb, enabled, last_run_at }automation_runs { id, automation_id, status, started_at, completed_at, result jsonb, error } // AI Employeesai_employee_jobs { id, tenant_id, title, instructions, status, sandbox_id, started_at, cost_usd }ai_employee_outputs { id, job_id, type, content, requires_approval } // Hubhub_links { id, tenant_id, title, url, icon, category, position }integrations { id, tenant_id, service, oauth_token_enc, scopes, connected_at } // Systemevents { id, tenant_id, type, payload jsonb, created_at }notifications { id, tenant_id, user_id, type, title, body, read, action_url }files { id, tenant_id, key, filename, mime_type, size_bytes, uploaded_by }audit_log { id, tenant_id, user_id, action, resource_type, resource_id, metadata jsonb, created_at }Cross-product relationshipsThe power of a unified database is that products reference each other natively:Tasks → Meetings: A task’s source_type can be ‘meeting’ and source_id references the meeting that generated it. The Task Manager shows "Created from meeting with Turkish Airlines."Deals → Activities → Meetings: A deal_activity can reference a meeting. The CRM timeline shows: "Feb 10: Meeting with Mehmet Yilmaz (view transcript)."Documents → Embeddings: Every document and meeting transcript is chunked and embedded. The Company Assistant searches across both in one vector query.Automations → Everything: An automation’s trigger_config can reference any table (deals, tasks, meetings). Its action_chain can write to any table.AI Employees → Tasks + Outputs: When an AI Employee completes work, it creates an output record. If the output requires approval, it creates a task assigned to the reviewing human.Notifications → Everything: Every notification has an action_url that deep-links to the relevant record in any product.Row-Level SecurityEvery table has tenant_id. PostgreSQL RLS policies enforce isolation:-- Applied to every tableALTER TABLE documents ENABLE ROW LEVEL SECURITY; CREATE POLICY tenant_isolation ON documents USING (tenant_id = current_setting('app.tenant_id')::uuid); -- Middleware sets this on every request:SET LOCAL app.tenant_id = '<tenant-uuid-from-jwt>'; -- Result: every query is automatically filtered.-- SELECT * FROM documents returns only the tenant's docs.-- No WHERE clause needed in application code.Local-first with Turso (Desktop + Mobile)For offline-capable features (Knowledge System browsing, task management, meeting transcript review), the desktop and mobile apps use Turso embedded replicas — a local SQLite database that syncs with the cloud PostgreSQL. Writes go to the cloud first (tRPC mutation), then sync down. Reads can be served from the local replica when offline. Yjs CRDTs handle conflict resolution for collaborative editing.7.3. The Embedding Pipeline (Semantic Search)The Company Assistant’s ability to search across 100,000+ documents and meeting transcripts depends on a vector embedding pipeline. Every piece of text content is automatically chunked, embedded, and indexed for semantic search.How it worksA document is created or updated in the Knowledge System (or a meeting transcript is finalized).The documents router emits a ‘document.updated’ event to the Event Bus.The embedding worker (background job) picks up the event.Worker chunks the content into ~500-token segments with 50-token overlap.Each chunk is sent to the embedding model (text-embedding-3-small via the managed API proxy, or a local model for self-hosted).Resulting vectors (1536 dimensions) are stored in the document_embeddings or meeting_embeddings table using pgvector.When the Company Assistant needs to answer a question, it embeds the query, runs a cosine similarity search across all embedding tables, and retrieves the top-K most relevant chunks as context for the LLM.What gets embeddedContent TypeSource TableEmbedding TableChunking StrategyKnowledge System docsdocumentsdocument_embeddings500-token chunks with heading context preservedMeeting transcriptstranscriptsmeeting_embeddingsBy speaker turn, grouped into ~500-token chunksMeeting summariesmeeting_summariesmeeting_embeddingsWhole summary as one chunk (usually <500 tokens)CRM notes & activitiesdeal_activitiesdeal_activity_embeddingsIndividual notes as chunksHub: connected Google Drive docs (Phase 2)external_documentsexternal_embeddingsSame as Knowledge SystemHub: Slack messages (Phase 2)external_messagesexternal_embeddingsThread-level chunksScale: pgvector with IVFFlat indexing handles 100K–500K embeddings efficiently on standard Neon instances. For larger deployments (1M+ embeddings), switch to HNSW index. No external vector database needed — everything stays in PostgreSQL.7.4. The Real-Time Sync LayerThree different real-time systems serve different purposes:Yjs CRDTs: Collaborative document editingWhen multiple employees edit the same Knowledge System document simultaneously, Yjs handles conflict-free merging. The web portal and desktop app both use TipTap (which has built-in Yjs support). The sync provider is a lightweight WebSocket server (Hocuspocus) that runs alongside the API server. Document state is persisted to PostgreSQL on every change. No data loss, no merge conflicts, no locking.Server-Sent Events (SSE): Live data updatesFor real-time but non-collaborative data (CRM updates, task changes, notification delivery, automation status, AI employee progress), the API server uses tRPC subscriptions over SSE. When a mutation occurs (e.g., a deal moves to a new stage), the Event Bus notifies all connected clients subscribed to that resource. The web portal and desktop app update instantly without polling.WebSocket: Meeting transcription streamDuring live meetings, the desktop overlay streams audio chunks to the transcription pipeline and receives transcript segments back in real-time. This is a dedicated WebSocket connection (not SSE) because it requires bidirectional streaming with low latency. The transcript is simultaneously written to the transcripts table and broadcast to the overlay UI.5.5. The Event BusThe Event Bus is the nervous system. Every significant action in any core product emits an event. Other products and systems subscribe to those events. This is how a CRM deal change can simultaneously trigger an automation, send a notification, update the MCP server’s cache, and log to the audit trail.ArchitectureIn-process pub/sub using Node.js EventEmitter for single-instance deployments (Phase 1–2). Upgrades to Redis Pub/Sub for multi-instance deployments (Phase 3+). The event shape is standardized:interface BasicOSEvent { id: string // Unique event ID (ULID) type: string // e.g. 'crm.deal.stage_changed' tenant_id: string // Tenant isolation user_id: string // Who triggered it payload: Record<string, any> // Event-specific data created_at: Date} // Example: deal moved to Stage 4{ type: 'crm.deal.stage_changed', tenant_id: '...', user_id: '...', payload: { deal_id: '...', deal_title: 'Turkish Airlines Partnership', from_stage: 'proposal_sent', to_stage: 'negotiation', value: 250000 }}Who emits eventsProductExample EventsKnowledge Systemdocument.created, document.updated, document.deletedCRMcrm.contact.created, crm.deal.stage_changed, crm.deal.won, crm.deal.lost, crm.activity.loggedMeeting Intelligencemeeting.started, meeting.ended, meeting.transcript.finalized, meeting.summary.generatedTask Managertask.created, task.completed, task.overdue, task.assignedAutomations Engineautomation.triggered, automation.completed, automation.failedAI Employeesai_employee.started, ai_employee.completed, ai_employee.approval_needed, ai_employee.killedAuth / Adminuser.invited, user.joined, user.role_changed, api_key.rotatedWho subscribes to eventsSubscriberListens ForWhat It DoesAutomations EngineAll product eventsChecks if any automation’s trigger matches. If yes, executes the action chain.Notification ServiceConfigurable per userSends in-app notification, push notification (mobile), and/or desktop overlay notification.Embedding Workerdocument.updated, meeting.transcript.finalizedRe-chunks and re-embeds the content for semantic search.Audit LoggerAll eventsWrites every event to the audit_log table. Immutable, append-only.SSE BroadcasterAll eventsPushes real-time updates to connected web/desktop/mobile clients.MCP Cache InvalidatorData change eventsInvalidates cached MCP resources so connected AI tools get fresh data.AI Employee Orchestratorai_employee.approval_neededCreates a task for the human reviewer. Pauses the job until approved.Example: What happens when a deal moves to Stage 4Sales rep drags the deal to "Negotiation" in the CRM pipeline view (web portal or desktop app).Web portal calls crm.deals.updateStage mutation via tRPC.tRPC procedure updates the deals table. Emits crm.deal.stage_changed event.Automations Engine receives the event. Matches a trigger: "When deal moves to Negotiation, send pricing sheet email." Executes: sends email via SendGrid, logs activity to deal_activities.Notification Service receives the event. Sends push notification to the deal owner’s mobile app: "Turkish Airlines moved to Negotiation." Shows in desktop overlay HUD.SSE Broadcaster receives the event. All connected clients showing the pipeline view update instantly — the deal card animates to the new column.Audit Logger writes the event to audit_log.MCP Cache Invalidator clears the cached CRM data. Next time an employee asks the Company Assistant about this deal, it gets fresh data.Total time from drag to all side effects completing: <500ms.5.6. Background WorkersSome operations are too slow or too expensive to run in the request path. These run as background workers — separate processes (or separate Railway services for managed hosting) that consume from a job queue.WorkerJob QueueWhat It ProcessesLatencyEmbedding WorkerBullMQ (Redis)Chunks and embeds documents and meeting transcripts5–30s per documentMeeting ProcessorBullMQ (Redis)Takes raw transcript + audio, runs LLM summarization, extracts action items, updates CRM30–60s per meetingAutomation ExecutorBullMQ (Redis)Runs automation action chains (email, API calls, AI prompts). Retries on failure.1–10s per actionAI Employee RunnerBullMQ (Redis)Orchestrates E2B sandbox lifecycle: provision VM, inject instructions, monitor, collect outputMinutes to hoursImport WorkerBullMQ (Redis)Bulk imports: Notion export, Google Drive sync, CSV upload, Confluence migrationVariesNotification DispatcherBullMQ (Redis)Sends push notifications (Expo Push), emails (SendGrid), and webhook calls<2sWhy BullMQ: Redis-based job queue with retries, priorities, rate limiting, and scheduled jobs. Already have Redis for rate limiting and caching. No additional infrastructure. Workers run as separate processes that can scale independently.5.7. The Company Assistant: How RAG Works End-to-EndThe Company Assistant is the most complex feature in the backend. Here is exactly how a question becomes an answer:Employee asks: "What did we agree with Turkish Airlines about volume pricing in our last meeting?"The assistant router receives the message. Appends it to the conversation history (stored in-memory per session, optionally persisted).Query Analysis: The LLM classifies the query and determines which data sources to search. For this query: meetings (mentions "last meeting"), CRM (mentions "Turkish Airlines", implies deal context), knowledge system (mentions "volume pricing", might be in a pricing doc).Parallel retrieval via MCP tools: (a) search_meetings({ query: "Turkish Airlines volume pricing" }) — embeds the query, runs cosine similarity against meeting_embeddings, returns top-3 transcript chunks. (b) query_crm({ company: "Turkish Airlines" }) — returns the deal record + recent activities. (c) search_knowledge({ query: "volume pricing" }) — searches document_embeddings, returns relevant doc chunks.Context assembly: All retrieved chunks are ranked by relevance score, deduplicated, and assembled into a context block. Total context budget: ~8,000 tokens (adjustable per plan).Prompt construction: System prompt ("You are ACME’s company assistant. Answer based only on the provided context. Cite sources.") + assembled context + conversation history + user’s question.LLM call: Sent to the API proxy (api.basics.so or direct BYOK). Model selection based on tenant config (default: Claude Sonnet or GPT-4o). Streaming response.Response streams back to the client. Citations are linked: "According to the meeting on Feb 10 [link], you agreed to 15% off on orders over 500 units. The updated pricing sheet [link] was uploaded by Sarah on Feb 12."The response is logged for analytics (which data sources were used, how many tokens, latency) and optionally stored for training feedback.SCALING TO 100K+ DOCUMENTSThe embedding pipeline + pgvector combination handles this. Each document is chunked into ~500-token segments. 100K documents × average 5 chunks each = 500K embeddings. pgvector with HNSW index searches 500K vectors in <50ms. The LLM only ever sees the top-K most relevant chunks (typically 5–10), so response quality stays high regardless of total corpus size.5.8. How It All Connects: The Full Data FlowThis diagram shows every major data flow in the backend. Every arrow is a real code path:┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐│ Web Portal │ │ Desktop App │ │ Mobile App ││ (Next.js) │ │ (Electron) │ │ (Expo) │└────────┬────────┘ └────────┬────────┘ └────────┬────────┘ │ │ │ └───────────────────┴───────────────────┘ │ ┌───────┴───────┐ │ tRPC API │ ← All clients │ Server │ call this │ (Hono v4) │ └──────┬────────┘ │ ┌──────────────┬─┴─────┬──────────────┐ │ │ │ │ ┌──────┴─────┐ ┌──┴───┐ ┌─┴───────┐ ┌─┴───────┐ │ PostgreSQL │ │ Redis │ │ Event Bus │ │ Job Queue │ │ (Neon) │ │ │ │ (Pub/Sub) │ │ (BullMQ) │ └────┬──────┘ └───────┘ └────┬─────┘ └────┬─────┘ │ │ │ │ ┌────────┴────────┴──────────┐ │ │ │ ┌────┴─────┐ ┌──┴──────────┬──────────┬─────────┐ │ pgvector │ │ Workers: │ │ │ │ embeddings │ │ - Embedding │ Meeting │ AI │ └───────────┘ │ - Meeting │ Proc. │ Employee│ │ - Automation│ │ Runner │ │ - Import │ │ │ └────────────┴──────────┴─────────┘ ┌───────────────────────┐ ┌─────────────────────┐ │ Company MCP Server │ │ Engineer MCP Server │ │ (calls tRPC directly) │ │ (calls tRPC / HTTP) │ └───────────┬───────────┘ └──────────┬──────────┘ │ │ ┌────────┬───────┬───────┬───────┬────────┘ │ │ │ │ │ ChatGPT Claude Cursor Copilot Claude Code5.9. Infrastructure Per Deployment ModeComponentSelf-Hosted (Mode A)Managed (Mode C)API ServerSingle Docker container (Hono + tRPC)Railway service, auto-scaledPostgreSQLSelf-managed or Neon free tierNeon (shared multi-tenant)RedisSelf-managed or Upstash free tierUpstash (shared)Yjs Sync ServerRuns in API server processSeparate Railway serviceBackground WorkersRun in API server process (single instance)Separate Railway services (scalable)File StorageLocal filesystem or S3-compatibleCloudflare R2Embedding ModelVia BYOK API key or local (Ollama)Via managed API proxyLLMVia BYOK API keysVia managed API proxy (api.basics.so)Company MCP ServerSame Docker Compose stackSeparate Railway serviceFor self-hosted single-instance deployments, the API server, Yjs sync, and background workers all run in one Node.js process with in-process pub/sub. This keeps deployment simple (one Docker container + Postgres + Redis). For managed multi-instance deployments, each component is a separate Railway service that scales independently.6. The Company Web PortalThis is the apps/web/ application in the monorepo — the Next.js app that every customer deploys for their employees. It lives at the company’s own domain (os.acmecorp.com for managed, or self-hosted on their own infrastructure). This is the first thing every user sees, and it is the only surface that ships in Phase 1 before the desktop or mobile apps exist.KEY DISTINCTIONDo not confuse this with basics.so. basics.so is OUR website where customers sign up and manage their subscription. The Company Web Portal is THEIR website — the internal tool their employees use every day. Each customer has their own instance.11.1. What Employees See (Employee View)When an employee at ACME Corp logs in to os.acmecorp.com, they see their company’s internal operating system. It is white-labeled with the company’s name, logo, and colors.Home / DashboardThe landing page after login. Shows:Quick actions: Start a meeting note, open the chatbot, view today’s tasks, check CRM.Recent activity: Latest changes across all modules — new CRM entries, updated docs, completed automations, AI employee outputs.Notifications: Mentions, assigned tasks, automation results, AI employee completions.App downloads: Links to download the branded Electron desktop app and (Phase 3) the iOS mobile app.Company AssistantA persistent AI interface available from every page via a sidebar or floating button. This is the most important feature in the entire product. It is not a chatbot — it is a company-wide AI that knows everything the company knows.Employee types a question: "What is the status of the ACME deal?"The web portal sends the question to the backend API (tRPC).Backend calls the Company MCP server, which searches across all data sources: CRM, Knowledge System, meeting transcripts, task manager, connected services (Slack, Drive).Backend constructs a prompt: employee’s question + all retrieved context + conversation history. Sends to the LLM via the API proxy.LLM response streams back in real-time.Employee sees: "The ACME deal is in Stage 3 (Proposal Sent). Last activity was 2 days ago when Sarah uploaded the pricing sheet. In your last meeting with them on Feb 10, they asked for a volume discount — this is addressed in the updated pricing sheet."What it can do: Search across 100,000+ internal documents. Find subject matter experts ("Who on our team knows Kubernetes best?"). Draft project plans grounded in company data. Answer questions about any internal process, policy, or historical decision. Query CRM data conversationally. Summarize any document. Trigger automations. Draft emails with full company context. Get status updates on AI employees. Everything is grounded in real company data, not hallucinated.What it cannot do: Access data the employee’s role does not permit. The Company MCP server enforces per-tool RBAC — a Viewer can search the knowledge base but cannot update it. An intern cannot see executive compensation data.The Core ProductsThese are not lightweight templates. They are the core product suite that makes BasicOS a complete company operating system. Each one is built with the module system (Section 10) but ships fully featured out of the box. The founding CTO activates which ones to use during setup.Company Assistant (The Brain): This is the most important feature. A persistent AI chat interface available from every page, the desktop overlay, and the mobile app. It is not a generic chatbot — it is grounded in the company’s entire knowledge graph. Employees can search across 100,000+ internal documents, find subject matter experts ("Who on our team knows the most about Kubernetes?"), draft project plans grounded in company context, get AI-powered answers about any internal process, CRM data, company policy, or historical decision. Think McKinsey’s Lilli but for every company. It connects to every other core product via the Company MCP server: it can query the CRM, search the knowledge system, check automation status, read meeting transcripts, and answer questions about anything in the company’s data.Knowledge System (Notion Replacement): A full document workspace — not a wiki, a Notion-class system. Rich docs with nested pages, databases, templates, and embeds. Real-time collaboration via Yjs CRDTs (multiple people editing the same doc simultaneously). TipTap editor for block-based rich text. But the key differentiator is that every document is automatically indexed for semantic search and exposed to the Company Assistant and MCP server. When an employee asks the chatbot "What was the decision on the Q3 pricing strategy?", the Knowledge System finds the relevant doc, extracts the answer, and cites the source. Supports: importing from Notion (API), Google Drive, Confluence. Phase 1 ships docs + search. Phase 2 adds databases (like Notion databases) and templates.CRM (Enterprise-Grade): Modeled on leading CRMs (HubSpot/Salesforce patterns). Pipeline management with visual deal stages and drag-and-drop. Contact and company management with custom fields, activity timeline, and relationship mapping. Deal tracking with weighted forecasting. Email integration: log emails against contacts automatically. Automated follow-ups via the automation system. The Company Assistant can query the CRM conversationally: "What deals are closing this month?" "Draft a follow-up to the Turkish Airlines contact." The CRM is deeply integrated with automations — every stage change, new contact, or missed follow-up can trigger a workflow.Task Manager: Kanban boards, to-do lists, assignees, due dates, labels, and project grouping. AI can create tasks from meeting summaries, chatbot commands, or automation triggers. Integrates with the overlay: during a meeting, when the AI detects an action item, it can auto-create a task.Automations Engine (Phase 2): Company-wide workflow automation, not just CRM. Visual builder: Trigger → Condition → Action chain. Triggers from any core product: new CRM entry, document updated, task completed, meeting ended, email received, scheduled time, chatbot command, AI employee output. Actions: send email, update CRM, create task, call external API, run AI prompt, start AI employee job, post to Slack, update a doc. Pre-built automation templates for common workflows: lead follow-up sequences, onboarding checklists, weekly digest reports, deal stage notifications. Admin can deploy and manage automations from the web portal. Employees can trigger them from the overlay or chatbot.AI Employees (Phase 3): Autonomous AI agents running in sandboxed VMs (E2B). Fork of Claude Code architecture — an AI agent with a browser, terminal, and file system inside a Firecracker microVM. Can execute real workflows: research competitors, update CRM records, draft reports, process data, manage spreadsheets. Trainable from the overlay: an employee records a workflow via Workflow Capture, the system generates step-by-step instructions, and an AI Employee can replay and adapt that workflow autonomously. Human-in-the-loop: AI employees request approval for irreversible actions. Monitor dashboard shows status, outputs, cost, and a kill switch.The Hub (Integration Center): A centralized directory connecting to everything the company uses. Quick-link cards for: Slack (with deep links to channels), Google Drive (shared folders), email, company perks portal, HR resources, benefits, org chart, team directory. Each card is a configurable link or embed — the admin sets them up during onboarding. The Hub is the company’s home page: when you need to find anything, start here. Connected services also feed data into the Company Assistant — when Slack and Google Drive integrations are configured, the chatbot can search across those sources too.Meeting Intelligence (Overlay + Web): Goes beyond simple transcription. During calls: real-time transcript (Granola-style), AI-generated live suggestions for what to say based on company context and goals for the call (Cluely-style), auto-detected action items, speaker identification. After calls: structured summary with decisions, action items, follow-ups, and sentiment analysis. Summaries auto-saved to the Knowledge System. Meeting prep: before a call, the AI pulls CRM data on the contact, recent email threads, last meeting notes, and presents a briefing. All searchable: "What did we agree with Turkish Airlines in the last meeting?"MCP Server Connection PageA settings page where employees connect their personal AI tools to the company’s MCP servers. Shows:Connection URL: The Company MCP server’s Streamable HTTP endpoint (e.g., https://mcp.acmecorp.com or https://mcp.basics.so/tenant-id for managed).Setup instructions: Step-by-step guides for connecting Claude Desktop, ChatGPT, Cursor, Copilot, and VS Code. Each guide shows exactly what to paste into the tool’s MCP settings.Connection status: Shows which of the employee’s AI tools are currently connected and active.Available tools: A list of all MCP tools the employee has access to based on their role, with descriptions and example queries.Onboarding FlowWhen a new employee is invited and creates their account, they land in a guided onboarding experience:Welcome screen with the company name and logo.Role selection: the admin has pre-assigned their role (Admin, Member, Viewer), but they can see what access it gives them.Tool tour: a brief walkthrough of the chatbot, CRM, knowledge base, and other active modules.MCP setup: guided flow to connect their AI tools (Claude, ChatGPT, etc.) to the Company MCP server.Desktop app download: prompt to install the Electron app for the overlay experience."You’re set" confirmation page with links to most-used tools.When the desktop app ships (Phase 2), this onboarding can also be delivered as a guided overlay walkthrough using the desktop’s step-by-step overlay system.11.2. What Admins See (Admin View)Admins see everything employees see, plus an admin sidebar with the following sections:Team ManagementInvite new members (email invite flow, with role pre-assignment).View all team members, their roles, last active date, and AI usage.Change roles (Admin / Member / Viewer) with project-level overrides.Deactivate or remove members (revokes all access, including MCP connections).AI Usage & Spend DashboardThe admin’s most important page. Shows:Total spend this billing period: Real-time dollar amount with a progress bar against the budget.Spend by model: Bar chart showing GPT-4o vs Claude vs other models.Spend by user: Which employees are using the most AI tokens.Spend by project/module: Which tools (chatbot, CRM, automations) consume the most.Daily trend: Line chart of daily spend over the past 30 days.Budget controls: Set a global budget, per-user budgets, or per-project budgets. When a budget is hit, requests are throttled or blocked with a notification to the admin.API Key ManagementView the team’s managed API key (masked, last 4 characters visible).Rotate the key (generates a new one, old key remains active for 48-hour grace period, then auto-revokes).For self-hosted (BYOK): manage individual provider keys (OpenAI, Anthropic, etc.).Test the key: a "Send test request" button that fires a simple prompt and confirms the proxy is working.MCP Server ManagementCompany MCP server: Status (healthy / degraded / down), connected clients count, recent tool invocations, error rate.Engineer MCP server (Phase 2): Same status view, plus a list of currently synced configs and which developers are connected.Tool permissions: Admin can configure which MCP tools are available to which roles. Example: Viewers can use search_knowledge_base but not update_knowledge_base.Module ConfigurationActivate or deactivate template tools (CRM, Meeting Notes, Knowledge Base, etc.).Configure custom fields for the CRM.Import data: bulk import contacts from CSV, docs from Notion/Google Drive.Scaffolding: launch the pnpm gen:module flow from the web UI (generates code in the repo that a developer then customizes).Security & AuditAudit log: every MCP tool invocation, every login, every role change, every API key rotation. Immutable, append-only.PII redaction settings: toggle Presidio PII detection on/off. Configure which entity types to redact (names, emails, SSNs, etc.).Session management: view active sessions across all employees, force logout.2FA enforcement: require 2FA for all team members or only admins.Branding & CustomizationCompany name, logo (displayed in the portal header and desktop app).Accent color (applied across all templates, the chatbot, and the desktop overlay).Custom domain configuration (for self-hosted: instructions; for managed: automatic via basics.so).Onboarding flow editor: customize the welcome text, tool tour, and MCP setup instructions for new employees.7.3. How the Portal Connects to EverythingThe web portal is not a standalone app. It is deeply integrated with every other component of BasicOS:Portal FeatureConnects ToHowCompany AssistantCompany MCP Server + API Proxy + all data sourcesSearches Knowledge System, CRM, meeting transcripts, Hub integrations. Sends prompt through LiteLLM proxy (or direct BYOK).Knowledge SystemPostgreSQL (Drizzle) + Yjs + Embedding pipelineDocs stored in DB, real-time collab via Yjs, auto-indexed for semantic search via embedding model.CRMPostgreSQL (Drizzle) + Automations EngineDirect DB access via tRPC. Every CRM event can trigger an automation.Meeting IntelligenceWhisper.cpp (desktop) or API Proxy (cloud STT) + LLMPhase 1: upload audio. Phase 2: desktop captures locally, syncs summaries. Coaching uses CRM + Knowledge data.Automations EngineCompany MCP Server + API Proxy + external APIsAutomations call MCP tools, LLM prompts, external services (Slack, email, webhooks).AI EmployeesE2B Sandboxes + LangGraph + Workflow CaptureVM-based agents. Trained from overlay recordings. Human-in-the-loop via web UI.The HubExternal services (Slack, Google Drive, etc.)Quick links + OAuth integrations. Connected services feed data into Company Assistant.MCP Connection PageCompany MCP ServerProvides the endpoint URL and OAuth flow for employees to connect their AI tools.Desktop App DownloadsElectron autoUpdater + Cloudflare R2Portal hosts .dmg and serves update manifests.7.4. Portal User Flows (Step by Step)Flow A: Employee asks the Company Assistant a questionEmployee clicks the Assistant icon (floating button, always visible on every page).Types: "Who is our contact at Turkish Airlines and what did we discuss last time?"Web portal sends the message via tRPC to the backend.Backend calls Company MCP server with multiple tool calls: search_crm({ query: "Turkish Airlines contact" }) and search_meetings({ query: "Turkish Airlines" }).MCP server queries PostgreSQL CRM and meeting transcript tables (filtered by RLS for the employee’s tenant).Returns: CRM contact record + last meeting summary with action items.Backend constructs prompt with all retrieved context + the employee’s question.Sends prompt to api.basics.so with the team’s virtual key.LLM response streams back: "Your contact at Turkish Airlines is Mehmet Yilmaz, Head of Partnerships. In your last meeting on Feb 10, you discussed the volume discount proposal. He asked for 15% off on orders over 500 units. Sarah was assigned to update the pricing sheet — that task is marked complete as of Feb 12."Employee follows up: "Draft a follow-up email to Mehmet confirming the updated pricing." The Assistant drafts the email grounded in the CRM data, meeting notes, and pricing sheet from the Knowledge System.Flow B: Admin sets up the portal for the first timeAdmin logs into the web portal for the first time (after deployment).Onboarding wizard launches: company name, logo upload, accent color picker.Admin selects which template modules to activate: Meeting Notes ✓, CRM ✓, Knowledge Base ✓, Task Manager ✗.Admin configures API: pastes their managed API key (from basics.so) or enters individual provider keys (BYOK).Admin invites team members: enters email addresses and assigns roles (Admin / Member / Viewer).System sends invite emails. Each employee gets a personalized link to create their account.Admin reviews the MCP server connection page: copies the Company MCP URL to share with engineers.Admin configures budget limits: $500/month total, $50/user maximum.Admin clicks "Launch" — the portal is live, employees can start using it.Flow C: Employee completes onboardingEmployee receives invite email: "Welcome to ACME’s OS. Click here to create your account."Clicks link, lands on os.acmecorp.com/onboarding.Creates account: name, email (pre-filled from invite), password (or SSO if configured).Welcome screen: "Welcome to ACME OS" with the company logo and a brief explanation.Role confirmation: "You’ve been set up as a Member. Here’s what you can do: [list of accessible tools]."Tool tour: brief interactive walkthrough of the chatbot ("Try asking a question"), the CRM ("Here’s where you find contacts"), and the knowledge base ("Search for a doc").MCP setup: "Connect your AI tools for superpowered productivity" with a toggle for Claude, ChatGPT, Copilot. Clicking any one shows paste-ready config.Desktop app: "Download the ACME OS desktop app for the overlay experience" with a .dmg download button.Confirmation: "You’re all set! Here are your bookmarks: [Chatbot] [CRM] [Knowledge Base]."Flow D: Admin monitors spend and adjusts budgetsAdmin navigates to Admin > AI Usage & Spend.Dashboard shows: $347 spent this month, $500 budget, 69% utilized. Trend is flat.Drills into "Spend by User": sees that one engineer is using $120/month on Claude Opus for code generation.Clicks the engineer’s name → sees a breakdown by model and by project.Decides to set a per-user limit: clicks "Set Budget" → enters $80/month for that engineer.System saves the budget. LiteLLM virtual key is updated with the new limit.If the engineer hits the limit, their requests return 429. They see: "You’ve reached your AI budget. Contact your admin."Admin receives a weekly digest email: "Last week: $89 spent, 12 users active, 1,432 requests. Top model: GPT-4o (68%)."7. The Desktop App (Electron)The desktop app is the power-user interface. Each customer company white-labels it with their branding (logo, colors, name) during setup. The app has two modes: a standard windowed dashboard and a transparent always-on-top overlay.11.1. The Main Window (Dashboard Mode)When an employee launches the app, they see a windowed dashboard that mirrors the web portal:Tool Launcher: Sidebar showing all active core products: Company Assistant, Knowledge System, CRM, Meeting Intelligence, Task Manager, Automations, AI Employees, The Hub.Company Assistant: Always accessible from the sidebar. Same AI grounded in all company data. Same MCP-powered context as web and mobile.Settings: Account, MCP connection status, notification preferences, overlay preferences, voice engine selection.White-labeling: During repo setup, the CTO configures app name, logo, accent color, domain. Electron reads this config and renders accordingly. Employees download a branded app from the web portal.11.2. The Overlay (Always-On-Top AI Assistant)The overlay is not a notification tray. It is an always-present AI assistant that sits on top of everything the employee does. It sees their screen, hears their meetings, guides them through tasks, answers their questions, records their workflows, and coaches them in real-time. It is the primary interface for power users — more important than the web portal.Overlay ArchitectureSingle Electron BrowserWindow: transparent: true, frame: false, alwaysOnTop: true ("screen-saver" level, stays above fullscreen apps), setVisibleOnAllWorkspaces(true), setIgnoreMouseEvents(true, { forward: true }) for click-through on non-interactive areas. The overlay renders React components that float on top of whatever the employee is doing. Activated from the tray icon or global hotkey (Cmd+Shift+Space).DESIGN PHILOSOPHYThe overlay is invisible until needed. It never blocks the employee’s work. When activated, it appears as a minimal floating panel that expands contextually. Think: a brilliant colleague who is always available but never interrupts.Capability 1: Voice-to-Action (Wispr Flow)A floating pill widget for voice commands and real-time transcription. The primary input method for the overlay.Activation: Global hotkey (Cmd+Shift+Space) or always-listening mode with a wake word.Speech-to-text engine: Whisper.cpp (small.en model, Apple Silicon Metal acceleration) for local processing. Falls back to Deepgram via managed API proxy for higher accuracy or non-English languages.Dictation mode: Transcribe speech directly into any active text field in any app. Works in Slack, email, Google Docs, code editors — anywhere there is a cursor.Command mode: Issue natural language commands that route to the Company MCP server. Examples: "What’s the status of the ACME deal?" → queries CRM. "Send the follow-up email to Mehmet" → triggers automation. "Summarize yesterday’s standup" → searches meeting notes. "Create a task for Sarah to review the proposal" → creates task.Quick questions: Ask anything about company data without switching apps. The overlay shows a compact response panel. "Who is our Kubernetes expert?" "What’s our refund policy?" "When is the next board meeting?"Build target: Phase 2a (May 2026) dictation. Phase 2b (Jun 2026) command routing.Capability 2: Meeting Intelligence (Granola + Cluely)Transforms every meeting from a time sink into structured, actionable output. Goes far beyond transcription.Before the meeting: When a calendar event starts, the overlay auto-prepares a briefing. Pulls CRM data on attendees, recent email threads, last meeting notes, open tasks related to the attendee or project, and the stated meeting agenda. Shows a compact briefing card: "Meeting with Mehmet Yilmaz, Head of Partnerships at Turkish Airlines. Last spoke Feb 10. Open deal: $250K, Stage 3. Your goal: get sign-off on the pricing sheet."During the meeting: Real-time transcript via Whisper.cpp floats beside the video call. Speaker identification labels who said what. AI-generated live coaching suggestions appear in a sidebar: what to say next based on the company’s goals for the call, objection handling based on CRM history, pricing guidance based on deal stage, relevant data points from the knowledge base. Action items are auto-detected as the conversation happens and shown in a running list.After the meeting: Structured summary generated: key decisions, action items (with assignees), follow-ups, sentiment analysis, and a "meeting score" (how well goals were met). Summary auto-saved to the Knowledge System (searchable by anyone with access). Action items auto-created as tasks in the Task Manager. Follow-up emails drafted and queued in the automation system. CRM updated with the latest activity.Build target: Phase 2b (May–Jun 2026) transcription + summarization. Phase 2c (Jun 2026) live coaching + meeting prep.Capability 3: Step-by-Step AI GuideThe overlay coaches employees through any workflow, step by step, in real-time. This is the onboarding and training system.Guided workflows: Admin (or the system) creates a walkthrough for any process: setting up AWS credentials, configuring a CI/CD pipeline, processing a customer refund, filling out an expense report, running a deployment. The overlay shows one step at a time: highlighted screen region, instruction bubble with text and optional voice narration, "Next" button. Employee completes each step in the actual application — the overlay validates completion before advancing.AI-generated guides: An employee (or admin) records a workflow via Workflow Capture (Capability 5). The system generates a step-by-step guide from the recording. That guide can then be replayed by any other employee. Example: a senior engineer records how to set up the dev environment. Every new hire gets a guided walkthrough that walks them through the exact same steps.Live AI assistance: Even without a pre-built guide, an employee can ask the overlay for help with any task. "How do I set up AWS?" The overlay uses the Company Assistant (grounded in the knowledge base and company docs) to generate step-by-step instructions in real-time, displayed as an overlay guide that the employee follows while actually doing the work.Use cases: Employee onboarding (first day setup, tool configuration, policy review), customer onboarding (show customers how to use the product), developer onboarding (dev environment, Git workflow, deployment), process training (expense reports, CRM data entry, compliance procedures), ad-hoc help ("how do I paste in these AWS commands?").Build target: Phase 2c (Jun 2026) for pre-built guides. Phase 3c (Nov 2026) for AI-generated guides from recordings.Capability 4: Workflow Recording & CaptureRecords an employee’s screen and interactions to generate documentation, automation scripts, and AI Employee training data.Recording: Employee activates recording from the overlay. desktopCapturer captures screen. macOS Accessibility API logs every click, keystroke, and semantic UI element label (button text, field names, menu items). Optional audio narration via microphone.Processing: When recording stops, captured data (video frames + accessibility log + audio transcript) is sent to a vision model (Claude or GPT-4o). The model generates:Step-by-step guide: annotated screenshots + written instructions, ready to deploy as a guided walkthrough (Capability 3).Automation script: Playwright/Puppeteer code that replays the workflow programmatically.AI Employee training: instructions an AI agent can follow in a sandboxed VM to execute the workflow autonomously.Process documentation: formatted doc auto-saved to the Knowledge System.The training loop: This is how AI Employees learn. An expert employee records themselves doing a task. The recording becomes training data. An AI Employee can then execute that task in a VM, adapting to variations. Over time, the AI Employee improves as more recordings are captured. This is the bridge between human knowledge and AI automation.Build target: Phase 3a (Aug–Sep 2026) recording. Phase 3b (Sep–Oct 2026) AI processing + training generation.Capability 5: Automation Deployment & ManagementEmployees can create, trigger, and monitor automations directly from the overlay without opening the web portal.Quick deploy: "Set up an automation that emails me when a deal moves to Stage 4" → the overlay asks for confirmation, then deploys the automation via the Automations Engine.Status panel: Shows running automations, recent triggers, success/failure counts. Compact view that expands on click.From recording to automation: After a Workflow Capture, the employee can choose "Deploy as automation" and the captured workflow becomes a recurring automation.Build target: Phase 2c (Jun–Jul 2026).Capability 6: Quick Actions & Notifications HUDThe minimal always-visible layer. A small floating panel that shows:Notifications: messages, automation results, AI employee status, task assignments, meeting reminders.Quick actions: start meeting recording, open chatbot, toggle voice mode, start workflow capture.AI Employee status: what AI employees are currently working on, with a quick-view of recent outputs.Build target: Phase 2a (May 2026). Ships with the initial desktop app.7.3. Overlay Build OrderPhaseDateCapabilityDepends On2aMay 2026Quick Actions & Notifications HUDElectron overlay shell2aMay 2026Company Assistant in overlayCompany MCP server (Phase 1)2aMay 2026Voice dictation (Wispr)Whisper.cpp integration2bMay–Jun 2026Meeting transcription + summarizationWhisper.cpp + LLM pipeline2bJun 2026Voice commands routingCompany MCP server tools2cJun 2026Meeting prep + live coachingCRM + Knowledge System + MCP2cJun 2026Pre-built guided walkthroughsStep-by-step overlay renderer2cJun–Jul 2026Automation deployment from overlayAutomations Engine3aAug–Sep 2026Workflow Capture recordingdesktopCapturer + Accessibility API3bSep–Oct 2026Workflow Capture AI processingVision model pipeline3bOct 2026AI Employee training from recordingsE2B + recording pipeline3cNov–Dec 2026AI-generated guided walkthroughsWorkflow Capture outputs7.4. Desktop App Packaging & DistributionThe critical design decision: white-labeling happens at runtime, not build time. We build and sign one universal binary. When an employee launches it, the app fetches branding from their company’s API and skins itself. This means self-hosted customers never need to compile Electron or purchase Apple Developer certificates.How We Build the BinaryCI/CD (GitHub Actions) runs electron-builder on every tagged release.Produces a universal macOS .dmg (arm64 + x86_64). Windows .exe and Linux .AppImage added in Phase 3.Code-signed with Basics’s Apple Developer certificate ($99/year, we pay this).Notarized with Apple’s notarization service (required for macOS distribution outside App Store, prevents Gatekeeper warnings).Binary uploaded to Cloudflare R2 (our CDN). Versioned: releases/desktop/v1.2.3/BasicOS-1.2.3-universal.dmg.How Employees Download ItThree download paths, all serving the same binary:From the company web portal: os.acmecorp.com/download/desktop. The portal proxies the download from R2 (managed) or hosts it directly (self-hosted). Download link includes a deep link token: BasicOS-1.2.3.dmg?company=acmecorp.com.From the invite email: The invite email includes a "Download the ACME OS desktop app" button with the same deep-linked URL.From basics.so: Generic download for anyone. On first launch, asks for the company URL manually.How White-Labeling Works at RuntimeEmployee opens the app for the first time.If launched from a deep link: company URL is pre-filled. If launched from generic download: app shows a "Connect to your company" screen where employee enters their company URL (os.acmecorp.com).App calls GET /api/branding on the company’s web portal. Returns: { name: "ACME OS", logo_url: "...", accent_color: "#E94560", api_endpoint: "...", mcp_endpoint: "..." }.App caches the branding config locally (Electron store). On subsequent launches, loads instantly from cache and refreshes in background.All UI renders with the company’s branding: logo in the sidebar, accent color on buttons, company name in the title bar.The macOS Dock icon and app name remain "BasicOS" (changing these requires a custom build). The window title shows the company name.CUSTOM BUILDS FOR POWER USERSSelf-hosted customers who want their company name in the Dock and a custom app icon can run: pnpm build:desktop. This reads their branding config from the local repo, sets the Electron bundle ID, app name, and icon, and produces a .dmg. They sign it with their own Apple Developer cert ($99/year) or distribute unsigned internally (employees must right-click > Open to bypass Gatekeeper).How Auto-Updates WorkOn launch, the app checks for updates via electron-updater.For managed customers: update server is releases.basics.so (our R2 bucket with a latest.yml manifest).For self-hosted customers: update server is os.acmecorp.com/api/desktop/update (the company web portal serves the manifest and binary).If an update is available, the app downloads it in the background and prompts: "A new version is available. Restart to update."Updates are differential (electron-updater supports delta updates on macOS), so only changed files download.Self-hosted customers control their own update cadence. They choose when to pull new releases from the BasicOS repo and rebuild.Desktop Distribution SummaryScenarioWho BuildsWho SignsWhere HostedUpdate ServerManaged (Mode C)Basics CI/CDBasics Apple certCloudflare R2 + company portalreleases.basics.soSelf-hosted + managed key (Mode B)Basics CI/CDBasics Apple certCompany portal proxies from R2Company portal /api/desktop/updateFully self-hosted (Mode A)Basics CI/CD (generic) or customer builds customBasics cert (generic) or customer cert (custom)Company portalCompany portal /api/desktop/update8. The Mobile App (Expo/React Native)On-the-go access. Shares 60%+ code with the web portal via shared packages. Built with Expo SDK 54+ using Continuous Native Generation.11.1. FeaturesCompany Assistant: Same AI grounded in all company data. Ask questions, draft emails, search documents, query CRM — all from your phone.CRM: Full pipeline view, contact management, deal tracking. Customizable fields. Log calls and notes on the go.Knowledge System: Browse and search docs. Create quick notes that sync to the full editor on web/desktop.Task Manager: To-do lists, daily planning, AI check-ins ("How is the cold outreach going?").Meeting Intelligence: Review meeting summaries, action items, and follow-ups. Prep for upcoming calls with AI briefings.AI Employee Monitor: Check on AI employee status, outputs, performance. Approve or reject actions that need human sign-off.The Hub: Quick access to Slack, Google Drive, company resources, perks. All linked from one place.Video Reporting: Record a quick video walkthrough from your phone; system generates a report or process doc.Push Notifications: Automations, AI employee approvals, team updates, meeting reminders, security events.Build target: Phase 3 (Aug–Oct 2026). CRM and chatbot first, then remaining features.11.2. Mobile App Packaging & DistributionSame pattern as Slack, Teams, and Notion: one app on the App Store, many companies inside it. White-labeling at runtime, not build time.The "One App" ModelWe publish a single app to the Apple App Store called "BasicOS" (or "Basics" if the name is taken). Every employee of every company downloads this same app. On first launch, the employee enters their company URL or scans a QR code from their invite email. The app authenticates via OAuth, fetches branding config, and renders with the company’s identity. From that point on, the app looks and feels like "ACME OS" — but it’s the same binary for everyone.This is the right approach because: it avoids maintaining separate App Store listings per customer, it lets us push updates to all companies simultaneously, and it means employees can download the app in 30 seconds instead of waiting for a custom build.How We Build and ShipWe use EAS Build (Expo Application Services) for cloud-based iOS builds. No Xcode on our machines. EAS runs on Expo’s infrastructure.Basics holds the Apple Developer account ($99/year) and the App Store listing.CI/CD (GitHub Actions) triggers an EAS Build on every tagged release. Produces a signed .ipa.For testing: EAS submits to TestFlight. Internal testers and design partners get early access.For production: EAS Submit pushes to the App Store. Apple reviews (typically 24–48 hours for updates).For JS-only updates (bug fixes, UI changes, new features that don’t touch native modules): EAS Update pushes an over-the-air (OTA) update. No App Store review. Users get the update next time they open the app.How White-Labeling Works at RuntimeEmployee downloads "BasicOS" from the App Store.First launch shows a "Connect to your company" screen. Employee enters their company URL or scans a QR code.App calls GET /api/branding on the company’s web portal. Returns: { name, logo_url, accent_color, api_endpoint, mcp_endpoint }.App caches branding locally (AsyncStorage/MMKV). Subsequent launches load instantly from cache.All screens render with company branding: logo on the login screen, accent color throughout, company name in the header.The App Store listing and iOS home screen icon remain "BasicOS". Inside the app, everything is branded.Push NotificationsBuilt on Expo Push Notifications service. Flow:On login, the app registers with Expo’s push service and receives a push token.Push token is sent to the company’s backend (tRPC endpoint) and stored per-user.When an event fires (automation completes, AI employee needs approval, teammate mentions you), the backend sends a push notification via Expo’s Push API.Expo routes it through Apple’s APNs. Employee sees the notification on their lock screen.Self-Hosted Customers Who Want Their Own App Store ListingThis is an advanced use case for large companies. The process:Customer forks the BasicOS repo’s apps/mobile/ directory.Updates app.config.ts with their own bundle ID (com.acmecorp.os), app name ("ACME OS"), icon, and splash screen.Creates their own Apple Developer account ($99/year) and Expo account.Runs eas build --platform ios to produce a signed .ipa with their branding baked in.Runs eas submit to push to the App Store under their own listing.They now own their App Store listing and update cadence. OTA updates via EAS Update still work.We provide a detailed build guide in the docs (docs.basics.so/mobile-custom-build), but this path is optional and only for customers who specifically need their own app icon on the home screen.Mobile Distribution SummaryScenarioApp Store ListingWho BuildsWho Pays Apple $99/yrUpdatesStandard (recommended)"BasicOS" on App StoreBasics via EAS BuildBasicsEAS Update (OTA) + App StoreCustom listing"ACME OS" on App StoreCustomer via EAS BuildCustomerCustomer controls cadenceWHY NOT BUILD CUSTOM BINARIES FOR EVERY CUSTOMER?Building, signing, and maintaining separate App Store listings per customer is operationally unsustainable and adds weeks of delay per customer. The one-app model (like Slack) lets us ship to everyone instantly. Runtime branding achieves 95% of the white-label effect. The remaining 5% (home screen icon, App Store listing name) only matters for large enterprises, and they can fork.9. The MCP ServersMCP (Model Context Protocol) is an open standard that lets AI tools connect to external data and tools. BasicOS ships two MCP servers. They are the nervous system — the reason every employee’s AI tools understand the company.11.1. Company MCP ServerThe most important differentiator. Any employee connects from whatever AI tool they use. When they ask a question, the AI tool calls the MCP server to get company context before answering.What it exposesMCP PrimitiveExamplesWho Sees ItResources (read-only)Knowledge base docs, process docs, org chart, product specsAll rolesTools (actions)search_kb, query_crm, create_crm_entry, trigger_automation, update_docsRole-based: viewers get read, admins get writePrompts (templates)Onboarding checklist, standup report, code review, sales email drafterAll rolesHow an employee connectsOpens their AI tool (Claude Desktop, ChatGPT, Cursor, etc.).Goes to MCP settings and adds the Company MCP server URL.OAuth 2.1 authenticates them against the BasicOS auth system.MCP server returns available tools and resources filtered by role.Employee asks: "What is the status of the ACME deal?" AI calls query_crm, gets data, answers.Transport: Dual — stdio for Claude Code and local IDE integration, Streamable HTTP for ChatGPT, remote Copilot, web-based tools.11.2. Engineer MCP ServerFor developers only. Syncs Claude Code configurations, skills, agent configs, and CLAUDE.md files across the team.Dynamic configuration: Team-wide CLAUDE.md snippets auto-update without git pulls.Environment-aware configs: Different rules for staging vs. production.Centralized skills distribution: One engineer writes a new Claude Code skill, it propagates to everyone.Team context injection: Sprint items, deployment status, team roster injected into every developer’s AI context.Build target: Company MCP in Phase 1 (Feb–May 2026). Engineer MCP in Phase 2 (Jun–Jul 2026).10. The Monorepo and Module SystemThis section is the most important one for developers. It explains the repo structure, how modules work, how new tools get built, and how the context file system teaches AI coding tools (Claude Code, Cursor, Copilot) to understand the entire architecture. A developer or AI agent reading this section should be able to build a new module from scratch and have it work across all platforms.11.1. Monorepo Structurebasicos/├── apps/│ ├── desktop/ # Electron macOS app (overlay + dashboard)│ ├── mobile/ # Expo React Native iOS app│ ├── web/ # Next.js company portal + admin│ └── mcp/│ ├── engineer/ # Engineer MCP server (dev sync)│ └── company/ # Company MCP server (business context)├── packages/│ ├── api/ # tRPC router definitions (shared backend)│ ├── db/ # Drizzle schema + migrations│ ├── ui/ # Tailwind + Radix shared components│ ├── shared/ # Business logic, types, Zod schemas│ ├── auth/ # Better Auth configuration│ ├── sync/ # Yjs real-time sync layer│ └── config/ # Shared ESLint, TypeScript, Tailwind├── templates/ # Module templates (CRM, notes, chatbot)├── infra/ # Docker Compose, Railway configs, IaC├── context/ # CLAUDE.md + per-module context files├── skills/ # Claude Code skills per module├── agents/ # Agent configs per project├── turbo.json├── pnpm-workspace.yaml└── docker-compose.yml11.2. What a Module IsA "module" is a self-contained business tool that plugs into BasicOS. The CRM is a module. Meeting Notes is a module. The Task Manager is a module. Each one follows the same structure and convention, which is what makes the system extensible — once you understand one module, you can build any new tool.Every module consists of exactly five layers:LayerLocationWhat It ContainsShared AcrossDatabase schemapackages/db/schema/[module].tsDrizzle table definitions, relations, indexes. Every table includes tenant_id for RLS.All platformsValidationpackages/shared/validators/[module].tsZod schemas derived from Drizzle types. Used for form validation, API input/output, and type inference.All platformsAPI routespackages/api/routers/[module].tstRPC router with queries and mutations. Imports Zod schemas for input validation. Protected by auth middleware.All platformsUI componentspackages/ui/modules/[module]/Shared React components (Tailwind + Radix for web/desktop, Tamagui for mobile). Forms, lists, detail views, charts.Web + Desktop (Radix), Mobile (Tamagui)Platform pagesapps/[platform]/pages/[module]/Platform-specific pages that compose shared components. Next.js pages for web, Electron views for desktop, Expo screens for mobile.Per platformIn addition to these five layers, every module has:Context file: context/modules/[module].context.md — a structured document that teaches AI coding tools everything about this module: its purpose, data model, API surface, UI patterns, known constraints, and examples.Claude Code skill: skills/[module]/ — a skill file that gives Claude Code specific instructions for working with this module (how to add a field, how to create a new view, common patterns).MCP registration: The module’s tRPC routes are automatically exposed as MCP tools in the Company MCP server. When a module is activated, employees can query it from any connected AI tool.Module manifest: templates/[module]/manifest.json — metadata: name, description, icon, default fields, whether it’s active by default, required permissions.11.3. The Type FlowThis is the core architectural pattern. One schema change propagates type safety from the database to every UI on every platform. No manual type duplication.1. Drizzle schema (packages/db/schema/inventory.ts) └─ export const items = pgTable('items', { id: uuid().primaryKey(), tenant_id: uuid().notNull(), name: text().notNull(), sku: text().notNull(), quantity: integer().notNull().default(0), ... }) 2. Zod validators (packages/shared/validators/inventory.ts) └─ import { createInsertSchema } from 'drizzle-zod' export const insertItemSchema = createInsertSchema(items) export const updateItemSchema = insertItemSchema.partial().required({ id: true }) export type Item = typeof items.$inferSelect export type NewItem = z.infer<typeof insertItemSchema> 3. tRPC router (packages/api/routers/inventory.ts) └─ export const inventoryRouter = router({ list: protectedProcedure.query(({ ctx }) => ...), create: protectedProcedure .input(insertItemSchema) .mutation(({ ctx, input }) => ...), update: protectedProcedure .input(updateItemSchema) .mutation(({ ctx, input }) => ...), }) 4. Client call (any platform) └─ const items = api.inventory.list.useQuery() // items is fully typed as Item[] // No manual type definitions anywhereWhen a developer adds a new column to the Drizzle schema (e.g., adds a "warehouse" field to the items table), the Zod schema updates automatically via drizzle-zod, the tRPC router’s types update, and every UI component that consumes the data gets a TypeScript error if it’s missing the new field. The developer (or Claude Code) fixes each consumer, and the change is complete across all platforms.11.4. Scaffolding a New Module: pnpm gen:moduleThis is the command a developer (or Claude Code) runs to create a new module. It uses Plop.js to generate all five layers plus the context file and skill.What the command does$ pnpm gen:module ? Module name: inventory? Description: Track physical inventory across warehouses? Platforms: web, desktop, mobile (select with spacebar)? Default fields: - name (text, required) - sku (text, required) - quantity (integer, default 0) - warehouse (text) - reorder_threshold (integer, default 10)? Include in Company MCP server? Yes? Active by default? No (admin enables manually) Generating module "inventory"... ✓ packages/db/schema/inventory.ts ✓ packages/db/migrations/0042_add_inventory.sql ✓ packages/shared/validators/inventory.ts ✓ packages/api/routers/inventory.ts ✓ packages/api/index.ts (router registered) ✓ packages/ui/modules/inventory/ItemForm.tsx ✓ packages/ui/modules/inventory/ItemList.tsx ✓ packages/ui/modules/inventory/ItemDetail.tsx ✓ apps/web/app/(dashboard)/inventory/page.tsx ✓ apps/web/app/(dashboard)/inventory/[id]/page.tsx ✓ apps/desktop/src/views/inventory/InventoryView.tsx ✓ apps/mobile/app/(tabs)/inventory/index.tsx ✓ apps/mobile/app/(tabs)/inventory/[id].tsx ✓ apps/mcp/company/tools/inventory.ts ✓ context/modules/inventory.context.md ✓ skills/inventory/SKILL.md ✓ templates/inventory/manifest.json Done! Run "pnpm db:migrate" to apply the schema.What the generated files look likeThe scaffolder does not generate empty stubs. It generates working code based on the fields the developer specified. The generated CRM-style list view, detail view, and form all work out of the box. The developer’s job is to customize from there — add business logic, custom views, integrations.Generated Drizzle schema: A complete pgTable with all specified fields, tenant_id, created_at, updated_at, and proper indexes. RLS-ready.Generated tRPC router: CRUD operations (list, getById, create, update, delete) with proper auth middleware, input validation via Zod, and tenant filtering.Generated UI components: A form component (with validation), a list component (with search, sort, pagination), and a detail view. All use the shared UI library (Tailwind + Radix for web/desktop, Tamagui for mobile). All consume the tRPC hooks directly.Generated MCP tool: A search_inventory and query_inventory tool registered in the Company MCP server. Employees can immediately ask the chatbot or their AI tools: "How many widgets do we have in the NYC warehouse?"Generated context file: A structured markdown file that tells AI coding tools everything about the module (see Section 9.5).Generated skill: A Claude Code skill with instructions specific to this module: how to add a field, how to create a custom view, how to add a new API endpoint.10.5. The Context File System (How AI Understands BasicOS)This is the mechanism that makes BasicOS AI-native. Every AI coding tool that supports context files (Claude Code reads CLAUDE.md, Cursor reads .cursorrules, Copilot reads .github/copilot-instructions.md) will automatically understand the entire BasicOS architecture and every module in it.KEY INSIGHTThe context files are not documentation for humans. They are structured instructions for AI coding agents. They tell the AI what exists, where to find it, what patterns to follow, and what mistakes to avoid. A developer can say "Add a warehouse field to the inventory module" and Claude Code will know exactly which files to touch across all five layers.The Context Hierarchybasicos/├── CLAUDE.md # Root context (10-15KB)├── context/│ ├── architecture.context.md # System-wide architecture│ ├── conventions.context.md # Code style, naming, patterns│ ├── modules/│ │ ├── crm.context.md # CRM module context│ │ ├── meeting-notes.context.md # Meeting Notes context│ │ ├── knowledge-base.context.md # Knowledge Base context│ │ ├── task-manager.context.md # Task Manager context│ │ └── inventory.context.md # (generated by pnpm gen:module)│ ├── platforms/│ │ ├── web.context.md # Next.js web portal patterns│ │ ├── desktop.context.md # Electron app patterns│ │ ├── mobile.context.md # Expo app patterns│ │ └── mcp.context.md # MCP server patterns│ └── infrastructure/│ ├── database.context.md # Drizzle, RLS, migrations│ ├── auth.context.md # Better Auth, RBAC│ └── deployment.context.md # Docker, Railway, CI/CD├── skills/│ ├── add-field/SKILL.md # Skill: add a field to any module│ ├── new-view/SKILL.md # Skill: create a new UI view│ ├── new-api-endpoint/SKILL.md # Skill: add a tRPC endpoint│ ├── new-mcp-tool/SKILL.md # Skill: register a new MCP tool│ ├── crm/SKILL.md # Module-specific skill│ ├── meeting-notes/SKILL.md│ └── inventory/SKILL.md # (generated by pnpm gen:module)└── agents/ ├── feature-builder.agent.md # Agent: build a feature end-to-end ├── bug-fixer.agent.md # Agent: diagnose and fix bugs └── module-creator.agent.md # Agent: create an entire new moduleRoot CLAUDE.md (What Every AI Session Reads First)The root CLAUDE.md is 10–15KB and gives any AI coding tool a complete mental model of BasicOS. It contains:Project overview: What BasicOS is, who uses it, the monorepo structure, the five platforms.Architecture rules: "Every table has tenant_id. Every tRPC route uses protectedProcedure. Every UI component imports from packages/ui. Never import directly between apps/."The type flow: Drizzle → Zod → tRPC → client. With concrete examples.Module anatomy: What a module consists of, where each layer lives, how to scaffold one.Platform patterns: How to add a page to the web portal, desktop app, and mobile app. Which UI library for which platform.MCP integration: How to register a new tool in the Company MCP server. How to expose module data to AI tools.Common tasks: Links to skills for frequent operations: "To add a field, read skills/add-field/SKILL.md. To create a new view, read skills/new-view/SKILL.md."What NOT to do: "Never use raw SQL. Never skip Zod validation. Never put business logic in platform-specific code. Never create a table without tenant_id."Per-Module Context FilesEach module’s .context.md follows a standard template:# Inventory Module ## PurposeTrack physical inventory items across warehouses withreal-time quantity updates and reorder alerts. ## Data Model- Table: items (packages/db/schema/inventory.ts)- Fields: id, tenant_id, name, sku, quantity, warehouse, reorder_threshold, created_at, updated_at- Relations: belongs to tenant- Indexes: (tenant_id, sku) unique, (tenant_id, warehouse) ## API Surface (packages/api/routers/inventory.ts)- inventory.list: Returns all items for tenant. Filterable by warehouse, searchable by name/sku.- inventory.getById: Single item by ID.- inventory.create: Validates via insertItemSchema.- inventory.update: Partial update via updateItemSchema.- inventory.delete: Soft delete (sets deleted_at).- inventory.lowStock: Items where quantity < reorder_threshold. ## UI Components (packages/ui/modules/inventory/)- ItemForm: Create/edit form. Uses shared FormField components.- ItemList: Searchable, sortable table. Uses shared DataTable.- ItemDetail: Single item view with edit button.- LowStockAlert: Banner shown when items are below threshold. ## MCP Tools (apps/mcp/company/tools/inventory.ts)- search_inventory: Full-text search across items.- query_inventory: Structured query (by warehouse, by SKU).- get_low_stock: Returns items below reorder threshold. ## Platform Pages- Web: apps/web/app/(dashboard)/inventory/page.tsx (list), [id]/page.tsx (detail)- Desktop: apps/desktop/src/views/inventory/InventoryView.tsx- Mobile: apps/mobile/app/(tabs)/inventory/index.tsx, [id].tsx ## Patterns & Constraints- All queries filter by ctx.tenantId (RLS enforced).- SKU must be unique per tenant.- Quantity cannot go negative (enforced in mutation).- Reorder alerts fire via the automation system when quantity drops below threshold. ## How to Extend- Add a field: Edit schema, run db:migrate, update Zod schema (auto), update form component, update list columns.- Add a view: Create component in packages/ui/modules/inventory/, add route in each platform.- Add an MCP tool: Create tool in apps/mcp/company/tools/, register in the tool index.Platform Context FilesEach platform has its own context file that explains platform-specific patterns:web.context.md: Next.js App Router conventions. Where to put pages, layouts, loading states. How to use Server Components for admin panels and Client Components for interactive features. How the sidebar navigation works. How to add a new item to the tool launcher.desktop.context.md: Electron window management. How the main window renders React views. How the overlay renders floating widgets. How to add a new view to the sidebar. How IPC works between main and renderer processes. How to add a new overlay capability.mobile.context.md: Expo file-based routing. How tab navigation works. How to use Tamagui instead of Radix. How to handle platform-specific UI (bottom sheets, haptics, pull-to-refresh). How push notifications integrate.mcp.context.md: How to define a new MCP tool. How to define a resource. How permissions work (which roles get which tools). How to test MCP tools locally with Claude Desktop.10.6. Claude Code SkillsSkills are step-by-step instructions for Claude Code to perform specific tasks. They are more actionable than context files — a context file says "here is how the system works," a skill says "here is exactly how to do this specific thing."Generic Skills (Work Across All Modules)SkillWhat It DoesFiles It Touchesadd-fieldAdd a new field to any module’s data modelschema/*.ts, validators/*.ts, form component, list columns, MCP tool, context.mdnew-viewCreate a new UI view for a modulepackages/ui/modules/*, apps/web/*, apps/desktop/*, apps/mobile/*new-api-endpointAdd a tRPC endpoint to a module’s routerpackages/api/routers/*.ts, packages/shared/validators/*.tsnew-mcp-toolRegister a new tool in the Company MCP serverapps/mcp/company/tools/*.ts, tool index, permissions confignew-overlay-widgetAdd a new floating widget to the desktop overlayapps/desktop/src/overlay/widgets/*.tsx, overlay registrynew-automation-triggerCreate a new trigger for the automation systempackages/api/routers/automations.ts, trigger registryModule-Specific SkillsEach module gets its own skill file (skills/[module]/SKILL.md) that contains instructions specific to that module. For example, the CRM skill knows about deal stages, pipeline views, and contact relationships. The Meeting Notes skill knows about Whisper.cpp integration, transcript formatting, and summarization prompts. These are generated by pnpm gen:module with sensible defaults and refined by the developer over time.Agent ConfigsFor more complex tasks that require multiple steps, the agents/ directory contains agent configurations:feature-builder.agent.md: Orchestrates building a complete feature. Reads the relevant context files, identifies all five layers, makes changes across all of them, runs tests, and commits. A developer can say: "Build a warehouse filter on the inventory list page" and the agent handles it end-to-end.module-creator.agent.md: Creates an entire new module from a natural language description. More powerful than pnpm gen:module because it can add custom business logic, complex views, and integrations based on the description. Example: "Create a hiring pipeline module with stages: Applied, Phone Screen, Onsite, Offer, Hired. Each candidate has a name, email, resume link, and notes."bug-fixer.agent.md: Given a bug report, reads relevant context files, identifies the likely source, proposes a fix, applies it, and runs tests.10.7. End-to-End Example: Building an Inventory TrackerHere is the complete developer experience of building a new module, from zero to working tool across all platforms. This is the story a CTO should be able to read and say "yes, my team can do this."Step 1: Scaffold the module$ pnpm gen:module? Module name: inventory? Description: Track inventory across warehouses? Platforms: web, desktop, mobile? Fields: name(text), sku(text), quantity(integer), warehouse(text), reorder_threshold(integer)? Include in Company MCP server? YesResult: 17 files generated across all five layers. Module exists but is not yet activated.Step 2: Run the migration$ pnpm db:migrateApplied migration 0042_add_inventory.sql ✓ Created table "items" with RLS policyStep 3: Customize with Claude CodeThis is where the AI-native architecture shines. The developer opens Claude Code and gives natural language instructions. Claude Code reads the generated context file, the platform context files, and the relevant skills:"Add a barcode field to the inventory module." Claude Code reads skills/add-field/SKILL.md and context/modules/inventory.context.md. Adds the column to the Drizzle schema, regenerates the migration, updates the Zod validator (automatic via drizzle-zod), adds the field to the form component, adds the column to the list view, and updates the context file."Add a low stock dashboard widget that shows items below threshold." Claude Code reads skills/new-view/SKILL.md and desktop.context.md. Creates a LowStockWidget component in packages/ui/, adds it to the web dashboard, adds it as an overlay widget on desktop, adds it as a mobile screen."Make the chatbot able to answer questions about inventory levels." Claude Code reads skills/new-mcp-tool/SKILL.md and mcp.context.md. The MCP tool was already generated by the scaffolder, but Claude Code can enhance it: add natural language query parsing, add warehouse-level aggregation, add trend analysis."Add a reorder automation: when quantity drops below threshold, create a task for the procurement team." Claude Code reads skills/new-automation-trigger/SKILL.md. Adds a trigger to the inventory router’s update mutation that checks quantity against threshold and creates a task via the task manager’s tRPC router.Step 4: Activate the moduleAdmin goes to the web portal admin panel → Module Configuration → sees "Inventory" in the inactive modules list → clicks "Activate." The module appears in the sidebar for all employees. The MCP tools become available to all connected AI tools. An employee can immediately ask the chatbot: "How many widgets do we have in the NYC warehouse?"Step 5: What just happenedIn about an hour, a developer (or AI agent) created a complete inventory tracking tool that:Has a database schema with RLS multi-tenancy.Has a type-safe API with CRUD operations and custom queries.Has a web portal UI with list, detail, and form views.Has a desktop app UI in both the dashboard and the overlay.Has a mobile app UI with the same functionality.Is queryable from any MCP-connected AI tool (ChatGPT, Claude, Copilot).Is queryable from the company chatbot.Has automation triggers for low stock alerts.Has a context file so any AI tool can understand and extend it further.Has a Claude Code skill so future developers can modify it with natural language.THIS IS THE MOATNo other open-source company OS has this combination: scaffolding that generates working code across five platforms, context files that make AI coding tools natively understand the architecture, and MCP integration that makes every module immediately accessible from any AI tool. A company can go from "we need an inventory tracker" to a working cross-platform tool in an hour.10.8. Module LifecycleStageWhat HappensWho Does ItScaffoldpnpm gen:module generates all five layers + context + skill + MCP toolDeveloper or Claude CodeMigratepnpm db:migrate applies the schema. Tables created with RLS.DeveloperCustomizeDeveloper (or AI agent) adds business logic, custom views, integrations. Context file is updated.Developer + Claude CodeTestpnpm test:module [name] runs generated tests. pnpm dev starts all platforms for manual testing.DeveloperActivateAdmin enables the module in the web portal. It appears in sidebar, MCP, chatbot.AdminExtendNew fields, views, automations added over time. Context file stays up to date.Developer + Claude CodeDeactivateAdmin disables the module. It disappears from the UI and MCP but data is preserved.Admin11. The Three Deployment ModesEvery customer falls into one of three modes. Each generates revenue differently.11.1. Mode A: Fully Self-Hosted (Free)Who: Technical founders who want full control.Revenue: Zero from hosting. Optional if they choose the managed API key.Clone: git clone https://github.com/basicos/basicos.gitSetup: pnpm install && pnpm setup. Wizard prompts for company name, logo, accent color, admin email, DB URL, and API keys.Deploy: docker-compose up -d (or Coolify one-click for easier management).Access web portal at their domain. Invite team.Team downloads the branded desktop app from the portal. Connects AI tools to MCP servers.11.2. Mode B: Self-Hosted + Managed API Key ($29–$99/mo)Who: Technical founders who self-host but do not want separate AI provider accounts.Revenue: Monthly subscription + usage-based billing (20–30% markup).Same self-hosting setup as Mode A.Go to basics.so/pricing, pick plan, pay via Stripe.Receive managed API key (bos_live_sk_...) displayed once.Replace provider keys in .env with single BasicOS key.Restart. All AI/TTS/STT routes through api.basics.so. Usage dashboard appears in admin panel.11.3. Mode C: Fully Managed Hosting ($99–$499/mo + usage)Who: Non-technical founders, or anyone who does not want to manage infrastructure.Revenue: Monthly hosting fee + usage-based billing.Go to basics.so, click "Deploy Your OS." Log in with GitHub.Pick Team ($99/mo) or Enterprise (custom). Pay via Stripe.Enter company name, logo, domain.Our backend provisions a Railway project: web portal, API, MCP server, PostgreSQL, Redis, LiteLLM. SSL auto-configured.Within 3–5 minutes: "Your BasicOS is live at os.acmecorp.com."Complete onboarding wizard, invite team, choose modules, set budgets. Everything just works.11.4. Revenue SummaryTierMonthlyAI CreditsWhat They GetFree (Self-Hosted)$0BYOKFull repo, all modules, community support, Docker ComposeStarter (API Key)$29$50 includedManaged API key, usage dashboard, email supportTeam (Key + Hosting)$99$200 includedOne-click deploy, SSO, audit logs, priority supportEnterpriseCustomCustomDedicated infra, SLA, compliance, custom integrationsAll paid tiers charge overage at 20–30% markup over raw provider costs. Flat-rate monthly (not per-seat) because we want every employee using it.12. Roadmap (From February 17, 2026)Phase 1: Foundation — Feb 17 to May 15, 2026GOALShip the web portal, Company MCP server, and managed API proxy. Get 10 startups using it. First paying customer.DatesDeliverableDetailsFeb 17 – Mar 7Monorepo scaffoldTurborepo + pnpm. All packages/. CLAUDE.md hierarchy. CONTRIBUTING.md. docker-compose.yml.Feb 17 – Mar 7Database + AuthDrizzle schema with RLS. Better Auth with org-level RBAC. Seed data.Mar 8 – Mar 28Company Web Portal MVPNext.js. Login, dashboard, company chatbot, meeting notes, CRM templates. Employee onboarding flow. Admin panel with team management and branding.Mar 8 – Mar 28Company MCP serverTypeScript. stdio + Streamable HTTP. Resources, Tools, Prompts. OAuth 2.1. Per-tool RBAC.Mar 29 – Apr 11Managed API proxyLiteLLM on Railway. Virtual key generation. TTS/STT middleware.Mar 29 – Apr 11Stripe integrationBilling Meters for usage. Starter and Team plans. Webhook handling.Apr 12 – Apr 25basics.so websiteMarketing + customer dashboard + docs. Pricing page. One-click API key provisioning.Apr 26 – May 8Hosting automationRailway Template. One-click deploy flow. Automated provisioning via Railway API.May 9 – May 15Open-source launchProduct Hunt, HN Show HN, r/selfhosted, Twitter thread, Discord server.Phase 2: Desktop + Dev Experience — May 16 to Aug 15, 2026GOALShip Electron desktop app with overlay. Launch Engineer MCP server. 5+ paying customers. 500+ GitHub stars.DatesDeliverableDetailsMay 16 – Jun 6Electron app shellDashboard mode. Tool launcher, sidebar, chatbot. White-label config.May 16 – Jun 6Overlay foundationTransparent alwaysOnTop window. Click-through. Tray + global hotkey. Quick Actions HUD.Jun 7 – Jun 27Meeting Notes overlayWhisper.cpp (small.en). Real-time transcript widget. LLM summarization.Jun 7 – Jun 27Wispr Flow (basic)Voice transcription in overlay. Dictation into active text fields.Jun 28 – Jul 11Wispr Flow (commands)Voice commands routed to Company MCP. "Send the follow-up to ACME."Jun 28 – Jul 11Engineer MCP serverCLAUDE.md sync, skills distribution, team context injection.Jul 12 – Aug 1Additional templatesOnboarding flow builder, automation builder, CRM enhancements.Aug 2 – Aug 15Hosting improvementsHelicone for usage dashboards. Stripe Credits. Monitoring.Phase 3: Full Platform — Aug 16, 2026 to Feb 2027GOALComplete the vision. Mobile, AI Employees, Workflow Capture. 2,000+ stars. 50+ paying teams. SOC 2 Type I.DatesDeliverableDetailsAug 16 – Sep 12Workflow Capture recordingdesktopCapturer + Accessibility API. Screen + audio + click/keystroke logging.Aug 16 – Oct 3Mobile app (Expo)CRM, chatbot, task manager, push notifications. 60%+ code sharing.Sep 13 – Oct 17Workflow Capture AIVision model pipeline. Onboarding guide, automation script, AI task prompt.Oct 18 – Nov 14AI Employee systemE2B sandboxed VMs. LangGraph orchestration. Human-in-the-loop gates.Nov 15 – Dec 5Guided Onboarding overlayStep-by-step walkthrough from Workflow Capture. Piper TTS + ElevenLabs.Dec 6 – Jan 2027Enterprise featuresSSO, fine-grained RBAC, audit logs, PII detection (Presidio), multi-region.Jan – Feb 2027SOC 2 Type IVanta automation. Policies, controls, readiness, audit.13. Security ModelData isolation: PostgreSQL RLS. tenant_id on every table. Middleware extracts from JWT. Automated cross-tenant tests in CI.Encryption: TLS 1.3 everywhere. AES-256-GCM for sensitive fields with per-tenant derived keys.API keys: Stored hashed (argon2). Displayed once. Rotation with 48-hour grace period. Prefixed: bos_live_, bos_test_.Auth: Better Auth with 2FA, passkeys, org-level RBAC (Admin/Member/Viewer), project overrides.MCP security: Per-tool RBAC. Immutable audit trail. Short-lived OAuth tokens. OWASP MCP Security Guide mitigations.PII handling: Presidio (open-source) detects/redacts PII before AI API calls. Visual recording indicator for screen capture.AI Employee safety: OAuth 2.1 delegation with scoped tokens. Read-only default. Time-bound permissions. Kill switch.Secrets: Infisical (open-source). Auto-rotation for Postgres and AWS IAM credentials.SOC 2: Start Day 1. Vanta for automation. Target Type I by Feb 2027.14. Go-to-Market14.1. Positioning"The open-source company operating system for startups that want to own their stack." Like Supabase vs Firebase. No competitor covers the full intersection: Operately lacks desktop and AI agents, Retool is not a company-wide OS, Notion is closed-source with no self-hosting.14.2. Launch Plan (May 9–15, 2026)Product Hunt submission (aim for #1 of the day).Hacker News "Show HN" with technical blog post on MCP architecture.Reddit: r/selfhosted, r/opensource, r/startups.Twitter/X thread: founder story + demo video.Discord server open from Day 1. GitHub with polished README, CONTRIBUTING.md, public roadmap.14.3. Target TrajectoryMilestoneDateStarsPaying TeamsOpen-source launchMay 2026200–1,0001–3Desktop app shipsJul 20261,000–3,0005–10Mobile + AI EmployeesNov 20263,000–7,00020–40SOC 2 + EnterpriseFeb 20275,000–10,00050–100Community-first, revenue-second. Cal.com had $20K MRR at their $32M Series A.15. Open QuestionsShould the Starter plan include more or fewer than $50 in credits?For managed hosting: host everything, or let companies keep their DB on their own AWS?How polished do module templates need to be if users customize everything with AI coding tools?Is E2B the right long-term choice, or should we build on raw Firecracker?Is the React Native app essential for Phase 2 or can it wait for Phase 3?How many target customers already use MCP-compatible tools? Is MCP awareness a GTM bottleneck?Right PII handling strategy for EU customers under GDPR + EU AI Act?